# 테이블뷰 구현이론 

Step 1. 테이블 뷰 배치

Step 2. 프로토타입 셀 디자인, 셀 아이덴티파이어(ID) 지정

Step 3. 데이터 소스, 델리게이트 연결

Step 4. 데이터 소스 구현

Step 5. 델리게이트 구현



* 데이터 소스와 델리게이트에 관하여 

  전재 조건은 '테이블 뷰는 바보다.' 라는 것을 깔고 가자. 테이블 뷰는 몇 개의 셀을 표시해야 하는지 모른다. 따라서 표시해야할 셀이 몇 개인지 테이블 뷰에게 알려줘야 한다. 그리고 어떤 디자인으로 표시해야 하는 지도 모른다. 그래서 프로토타입 셀을 직접 디자인하고 이 디자인을 사용하라고 알려줘야 한다. 여기에 더해서 어떤 데이트를 표시해야하는지 모르기 때문에 표시해야할 데이터도 직접 지정해야 한다. 이런 역할을 하는 객체를 데이터 소스라고 한다. 데이터 소스를 문법적으로 설명하면 UITableViewDataSource 프로토콜을 채용한 형식이다. UITableViewDataSource 프로토콜에는 테이블 뷰에 데이터를 표시하는 다양한 메소드들이 선언되어 있다. UITableViewController Class는 기본적으로 UITableViewDataSource를 채용하고 있다. 그리고 테이블 뷰의 데이터 소스로 지정되어 있다. 이런 부분은 내부적으로 자동으로 처리된다.
  테이블 뷰는 어떤 데이터를 어떤 디자인으로 몇 개를 출력해야 할지 모른다고 했다. 그래서 항상 데이터 소스한테 물어봐야한다. 테이블 뷰는 데이터 소스에 구현되어 있는 메소드를 호출하는 방식으로 해당 정보들을 물어본다. 그렇다면 대답은 어떻게 할까? 이 대답은 메소드의 return 값을 가지고 답변을 받는다.  

  ```swift
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  				let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)
          // Configure the cell...
          let target = Memo.dummyMemoList[indexPath.row]
          cell.textLabel?.text = target.content
          cell.detailTextLabel?.text = target.insertDate.description
    }
  ```

  위 메소드는 보통 3단계로 구현한다. 

  1. 사용한 cell 디자인을 가져온다. withIdentifier에서 파라미터로 "cell"을 전달하고 있다. 이 셀을 지정했던 cell ID로 이를 가지고 프로토타입 셀 중에서 cell 이라는 ID를 가진 셀을 자동으로 만들어 준다. (디자인) 그리고 그 셀을 cell이라는 상수에 저장을 해 준다. 그리고 셀이 생성되는 시점에는 셀이 비어있다. 
  2.  `let target = Memo.dummyMemoList[indexPath.row]`이 코드를 가지고 표시할 데이터를 가져온다. 
  3. 이어서 실제 데이터를 셀에 추가되어 있는 레이블에 표시한다. 
  4. 마지막에는 cell을 리턴하여 이 셀을 테이블 뷰에 구현한다. 

  
  보통 셀을 터치하면 다른 화면으로 이동한다. 테이블 뷰는 바보이기 때문에 테이블 뷰를 터치했을 때 어떻게 해야하는지 모른다. 이것도 직접 알려줘야 한다. 만약 이런 이벤트를 처리하고 싶다면 델리게이트를 연결하고 필요한 메소드를 구현해야 한다. 데이터 소스는 필수이지만 델리게이트는 필수가 아니기 때문에 이벤트를 처리할 필요가 없다면 구현하지 않아도 된다.  

